import Container from './../../components/Container'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import PlatformTabs from '../../components/PlatformTabs'
import PlatformTabItem from '../../components/PlatformTabItem'
import CloudBanner from '../../components/CloudBanner'

# API

## Initialization

To setup the client you need to configure it with your `projectId` which you can obtain from [WalletConnect Cloud](https://cloud.walletconnect.com).

Furthremore you may need to configure the `domain` and `isLimited` parameters:

- `domain` defaults to `window.location.host` and must be set to the domain setup in [Cloud Setup](../cloud-setup). For example `app.example.com`. Do not add the scheme (`https://`).
- `allApps` determines if your app has access to all of the user's subscriptions, or only the ones that the app is hosted on. By setting it to `true`, it enables setting `domain` to a value other than `window.location.host`. Setting `allApps: true` can be useful during development to allow your localhost-deployed app to access the subscriptions for the domain you setup. Note that most apps do not need to set this in production environments, as they only need access to their own subscriptions. When enabled, the user has to sign a SIWE message granting your app more permissions, and this requires additional consideration from the user. Read [here](../authorization-signatures/about) for more details.

<PlatformTabs
    groupId="w3iw"
    activeOptions={["react", "javascript"]}
>

<PlatformTabItem value="react">

```ts
initWeb3inboxClient({ projectId, domain, allApps, logLevel })
```

#### References

- **projectId:** Your WalletConnect project ID
- **domain _(Optional)_:** Your app's domain. Defaults to `window.location.host`.
- **allApps _(Optional)_:** Set to `true` to request access to all of the user's notification subscriptions for all apps, instead of only `domain`. Defaults to `false`.
- **logLevel _(Optional)_:** Increase verbosity of console logging. Defaults to `error`. Can be set to `error`, `info`, or `debug`.

</PlatformTabItem>

<PlatformTabItem value="javascript">

```ts
const client = await Web3InboxClient.init({ projectId, domain, allApps })
```

#### References

- **projectId:** Your WalletConnect project ID
- **domain _(Optional)_:** Your app's domain. Defaults to `window.location.host`.
- **allApps _(Optional)_:** Set to `false` to request access to all of the user's notification subscriptions for all apps, instead of only `domain`. Defaults to `true`.

</PlatformTabItem>
</PlatformTabs>

## Managing Account

### Setting account for web3inbox

<PlatformTabs
    groupId="w3iw"
    activeOptions={["react", "javascript"]}
>

<PlatformTabItem value="react">

```ts
const {
  data: account,
  isRegistered,
  identityKey,
  setAccount,
  error,
  isLoading
} = useW3iAccount('eip155:1:0x9A...')
```

#### References

- **data:** CAIP-10 account currently active in Web3Inbox
- **setAccount:** Change actively managed account in Web3Inbox. Does not need to be used as you can set the account directly in the params.
- **isRegistered:** A boolean of whether or not the account currently set is registered
- **identityKey:** Currently set account's identity key
- **error:** A string, representing possible error of setting an account.
- **isLoading:** A boolean, representing if an account is being set

</PlatformTabItem>

<PlatformTabItem value="javascript">

```ts
await client.setAccount('eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029')

const account = client.getAccount() // eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029

client.watchAccount(account => {
  console.log({ account }) // eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029
})
```

#### References

- **account:** CAIP-10 account currently active in Web3Inbox
- **setAccount:** Change actively managed account in Web3Inbox
- **watchAccount:** Watcher ticks whenever the account updates

</PlatformTabItem>
</PlatformTabs>

### Registering an account

<PlatformTabs
    groupId="w3iw"
    activeOptions={["react", "javascript"]}
>

**Note**: [EIP-1271 signatures](https://eips.ethereum.org/EIPS/eip-1271) coming from smart wallets are supported in version `1.1.0` and above.

<PlatformTabItem value="react">

```ts
import { useSignMessage } from '@wagmi'
const { signMessageAsync } = useSignMessage()

const { isRegistered } = useW3iAccount('eip155:1:0x9A...')

const { prepareRegistration } = usePrepareRegistration()
const { register, isLoading: isRegistering } = useRegister()

const handleRegistration = async () => {
  try {
    const { message, registerParams } = await prepareRegistration()
    const signature = await signMessageAsync({ message: message })
    await register({ registerParams, signature })
  } catch (registerIdentityError: any) {
    console.error(registerIdentityError)
  }
}
```

#### References

- **isRegistered:** A boolean of whether or not the account currently set is registered
- **prepareRegistration:** Prepare registration params
- **register:** Register using a signature and register params
- **isLoading:** A boolean, representing if an account is being registered

Some suggested methods of signing the message:

- `@wagmi/core` [`signMessage` method](https://wagmi.sh/core/api/actions/signMessage)
- The [`useSignMessage` hook](https://wagmi.sh/react/hooks/useSignMessage) in `@wagmi`
- Ethers.js [`Wallet.signMessage` method](https://docs.ethers.org/v5/api/signer/#Signer-signMessage)

</PlatformTabItem>

<PlatformTabItem value="javascript">

```ts
import { signMessageAsync } from '@wagmi/core'

const { registerParams, signature } = await client.prepareRegistration({
  account
})
const isRegistered = await client.getAccountIsRegistered(account)
const signature = await signMessageAsync({ message })
await register({ registerParams, signature })
```

#### References

- **prepareRegistration:** Prepare registration params
- **register:** Register using a signature and register params
- **getAccountIsRegistered:** Returns if account is registered

Some suggested methods of signing the message:

- Ethers.js [`Wallet.signMessage` method](https://docs.ethers.org/v5/api/signer/#Signer-signMessage)
- `@wagmi/core` [`signMessage` method](https://wagmi.sh/core/api/actions/signMessage)
- The [`useSignMessage` hook](https://wagmi.sh/react/hooks/useSignMessage) in `@wagmi`

</PlatformTabItem>
</PlatformTabs>

## Managing Subscription

Subscribe, Unsubscribe, Get Subscription, Check if Subscribed.

:::note
When using `differentAccount`, the passed account needs to be previously registered.
This use case is for Dapps that have multile active accounts or wallets with multiple active accounts.
`differentAccount` can be used for all the below hooks and functions that accept `account`
:::

<PlatformTabs
    groupId="w3iw"
    activeOptions={["react", "javascript"]}
>

<PlatformTabItem value="react">

```ts
const { subscribe, isLoading: isSubscribing } = useSubscribe()
const { unsubscribe, isLoading: isUnsubscribing } = useUnsubscribe()

// get subscription of current user to current dapp
const { data: subscription, getSubscription } = useSubscription()

// getSubscription can be used to get information about different dapps programatically
const subscriptionToSameDappFromDifferentAccount = getSubscription(differentAccount)
const subscriptionToDifferentDappFromSameAccount = getSubscription(undefined, differentDappDomain)
const subscriptionToDifferentDappFromDifferentAccount = getSubscription(
  differentAccount,
  differentDappDomain
)

// subscribe to current dapp from current user
subscribe()
// subscribe to current dapp from different user
subscribe(differentAccount)
// subscribe to different dapp from current user
subscribe(undefined, differentDappDomain)
// subscribe to different dapp from different user
subscribe(differentAccount, differentDappDomain)

// unsubscribe from current dapp
unsubscribe()

// get all subscriptions for current account
const subscriptions = useAllSubscriptions()

const isSubscribed = Boolean(subscription)
```

#### References

- **account _(Optional)_:** CAIP-10 account
- **domain _(Optional)_:** dapp domain
- **subscribe:** Function to subscribe to current dApp `() => void`
- **unsubscribe:** Function to unsubscribe to current dApp `() => void`
- **isSubscribed:** Reactive state, checking if subscribed to dApp `Boolean`
- **isSubscribing:** If `subscribe()` is in-progress and has not finished yet
- **isUnsubscribing:** If `unsubscribe()` is in-progress and has not finished yet
- **subscription:** Reactive state, returning current subscription information, of type:

```ts
{
  topic: string
  account: string
  relay: relayertypes.protocoloptions
  metadata: Metadata
  scope: ScopeMap
  expiry: number
  symkey: string
  unreadCount: number
}
```

- **subscriptions:** Reactive state, returning array of current subscriptions

</PlatformTabItem>
<PlatformTabItem value="javascript">

```ts
// check if current account is subscribed to current dapp
const isSubscribed = client.isSubscribedToDapp()

// watch if current account is subscribed to current dapp
client.watchIsSubscribed(isSubbed => console.log({ isSubbed }))

// subscribe to current dapp with current account
await client.subscribeToDapp()

// subscribe to same dapp with different account
await client.subscribeToDapp(differentAccount)

// subscribe to different dapp with current account
await client.subscribeToDapp(undefined, differentDomain)

// subscribe to different dapp with different account
await client.subscribeToDapp(differentAccount, differentDomain)

// unsubscribe from current dapp with current account
await client.unsubscribeFromDapp()

// get current account's subscription to current dapp
const subscription = client.getSubscription()

// watch current account's subscription to current dapp
client.watchSubscription(subscription => console.log({ subscription }))

// get current account's subscriptions
const subscriptions = client.getSubscriptions()

// watch current account's subscriptions
client.watchSubscriptions(subscriptions => console.log({ subscriptions }))
```

#### References

- **account _(Optional)_:** CAIP-10 account
- **domain _(Optional)_:** dapp domain
- **subscription:** _Non-Reactive_ state, returning current subscription information, of type:

```ts
{
  topic: string
  account: string
  relay: relayertypes.protocoloptions
  metadata: Metadata
  scope: ScopeMap
  expiry: number
  symkey: string
  unreadCount: number
}
```

- **subscription:** _Non-Reactive_ state, returning array of current subscriptions

</PlatformTabItem>
</PlatformTabs>

## Managing Notifications

Get notifications

<PlatformTabs
    groupId="w3iw"
    activeOptions={["react", "javascript"]}
>

<PlatformTabItem value="react">

```ts
// watch notifications of current account's subscription to current dapp
const notificationsPerPage = 5
const isInfiniteScroll = true
const unreadFirst = true

const {
  data: notifications,
  nextPage,
  markNotificationsAsRead,
  markAllNotificationsAsRead
} = useNotifications(
  notificationsPerPage, 
  isInfiniteScroll,
  account,
  domain,
  unreadFirst,
  onRead // optional function to run whenever messages are read
)

// marking a single notification as read
await notifications[0].markAsRead();

// mark specific notifications as read for default account and under default domain
await markNotificationsAsRead(notifications.slice(2).map(n => n.id));

// mark specific notifications as read for specified account under default domain
await markNotificationsAsRead(notifications.slice(2).map(n => n.id), differentAccount);

// mark specific notifications as read for default account under specified domain
await markNotificationsAsRead(notifications.slice(2).map(n => n.id), undefined, differentDomain);

// mark specific notifications as read for specified account under specified domain
await markNotificationsAsRead(notifications.slice(2).map(n => n.id), differentAccount, differentDomain);

// mark all notifications as read for default account under default domain
await markAllNotificationsAsRead();

// mark all notifications as read for specified account under default domain
await markAllNotificationsAsRead(differentAccount);

// mark all notifications as read for default account under specified domain
await markAllNotificationsAsRead(undefined, differentDomain);

// mark all notifications as read for specified account under specified domain
await markAllNotificationsAsRead(differentAccount, differentDomain);


```

#### References

- **useNotifications()**
  - **notificationsPerPage:** Number representing how many notifications to get per fetch
  - **isInfiniteScroll:** Whether or not to keep already fetched notifications when getting next page
  - **params:** (optional) Additional parameters
  - **unreadFirst:** (optional, default `true`, since 1.3.0) Whether or not unread messages should be sorted at the top, regardless of timestamp
- **nextPage:** A function to be called to fetch the next page of notifications
- **notifications:** Array of notifications, of type
- **notification.read:** Mark the notification as read
- **markNotificationsAsRead**: Takes an array of notification IDs and marks them as read. Max 1000 IDs
- **markAllNotificationsAsRead**: Mark all notifications as read.

```ts
{
  title: string
  sentAt: number
  body: string
  id: string
  isRead: boolean
  url: string | null
  type: string
  markAsRead: () => Promise<void>
}
```

</PlatformTabItem>
<PlatformTabItem value="javascript">

You can retrieve notifications using pagination. One approach is to provide the last notification's ID as the starting point:

```ts
const notificationsPage = client.getNotificationHistory({
  limit: 3,
  // The `id` of the last notification, for example:
  startingAfter: 'some-notification-id'
})

const notificationsPerPage = 5
const isInfiniteScroll = true
const unreadFirst = true

let notifications = []

const onUpdate = ({notifications: fetchedNotifications}: GetNotificationsReturn) => {
  notifications = fetchedNotifications
}

const {
  nextPage,
  markNotificationAsRead,
  markAllNotificationsAsRead
} = client.pageNotifications(
  notificationsPerPage,
  isInfiniteScroll,
  specifiedAccount // OR undefined,
  specifiedDomain // OR undefined,
  unreadFirst
)(onUpdate)


// marking a single notification as read
await notifications[0].markAsRead();

// mark specific notifications as read
await markNotificationsAsRead(notifications.slice(2).map(n => n.id));

// mark all notifications as read
await markAllNotificationsAsRead();
```

#### References

- **pageNotifications:**
  - **notificationsPerPage:** Number representing how many notifications to get per fetch
  - **isInfiniteScroll:** Whether or not to keep already fetched notifications when getting next page
  - **params:* (optional) Additional parameters
  - **unreadFirst:** (optional, default `true`, since 1.3.0) Whether or not unread messages should be sorted at the top, regardless of timestamp
- **onUpdate:**: A callback that will be called whenever notifications get updated
- **nextPage:**: A function to be called to fetch the next page of notifications
- **notifications:** Array of notifications, of type
- **notification.markAsRead:** Mark the notification as read
- **markNotificationsAsRead**: Takes an array of notification IDs and marks them as read. Max 1000 IDs
- **markAllNotificationsAsRead**: Mark all notifications as read.

```ts
{
  title: string
  sentAt: number
  body: string
  id: string
  isRead: boolean // since 1.3.0
  url: string | null
  type: string
  read: () => Promise<void> // since 1.3.0
}
```

</PlatformTabItem>
</PlatformTabs>

## Notification Types

Manage and fetch notification types.

<PlatformTabs
    groupId="w3iw"
    activeOptions={["react", "javascript"]}
>

<PlatformTabItem value="react">

```ts
const { data: types, update } = useNotificationTypes()
```

#### References

- **update:** `(enabledScopeNames: string[]) -> void`
- **types:** Map of scopes (Notification types)

```ts
type ScopeMap = Record<
  string,
  {
    name: string
    description: string
    enabled: boolean
  }
>
```

</PlatformTabItem>
<PlatformTabItem value="javascript">

```ts
// get scopes of current account's subscription to current dapp
const types = client.getNotificationTypes()

// watch scopes of specific account's subscription to specific dapp
client.watchNotificationTypes(scp => {
  console.log(scp)
})

client.update(['enabledType-1', 'enabledType-2'])
```

#### References

- **update:** `(enabledScopeNames: string[]) -> void`
- **types:** Map of scopes (Notification types)

```ts
type ScopeMap = Record<
  string,
  {
    name: string
    description: string
    enabled: boolean
  }
>
```

</PlatformTabItem>
</PlatformTabs>

## Registering for Device Push Notifications

If you wish to receive live push notifications to your React Native or Web app, you must integrate with Firebase Messaging. More information about how to integrate with Firebase can be found [here](https://firebase.google.com/docs/cloud-messaging).

Your integration will obtain a token from Firebase and you will need to pass this token to the Web3Inbox SDK using the `registerWithPushServer()` function.

<PlatformTabs
    groupId="w3iw"
    activeOptions={["react", "javascript"]}
>

<PlatformTabItem value="react" >

```ts
import { getToken } from 'firebase/messaging'

const { data: client } = useWeb3InboxClient()

// initialize Firebase's messaging object via Firebase's `getMessaging` function

const firebaseToken = getToken(firebaseMessaging, {
  vapidKey: 'YOUR_FIREBASE_VAPID_KEY'
})

client.registerWithPushServer(firebaseToken)
```

#### References

- `registerWithPushServer`: `(token: string, platform: 'fcm' | 'apns' = 'fcm') => void`

Either APNs or FCM can be used to receive push notifications to the device. The `token` you provide may be a token from either platform, provided the `platform` argument matches.

</PlatformTabItem>

<PlatformTabItem value="javascript" >

```ts
import { getToken } from 'firebase/messaging

// initialize Firebase's messaging object via Firebase's `getMessaging` function

const firebaseToken = getToken(firebaseMessaging, {
  vapidKey: "YOUR_FIREBASE_VAPID_KEY"
})

// The Client ID that registered with this token, can be used for debugging purposes or logs
const clientId = client.registerWithPushServer(firebaseToken)
```

#### References

- `registerWithPushServer`: `(token: string, platform: 'fcm' | 'apns') => string`

Either APNS or FCM can be used to recieve push notifications. Token here is the respective platform's token.

</PlatformTabItem>

</PlatformTabs>

<PlatformTabs
    groupId="w3iw"
    activeOptions={["react", "javascript"]}
>

## Listening For Events

This can be used to listen to, for example, messages recieved in realtime.

<PlatformTabItem value="react" >

```ts
const { data: client } = useWeb3InboxClient()

client.on('notify_message', ({ message }) => {
  console.log(notification.title)
})
```

#### References

- `message`: Notification of type:

```ts
interface NotifyNotification {
  title: string
  sentAt: number
  body: string
  id: string
  url: string | null
  type: string
}
```

</PlatformTabItem>

<PlatformTabItem value="javascript" >

```ts
client.on('notify_message', ({ notification }) => {
  console.log(notification.title)
})
```

#### References

- `message`: Notification of type:

```ts
interface NotifyNotification {
  title: string
  sentAt: number
  body: string
  id: string
  url: string | null
  type: string
}
```

</PlatformTabItem>
</PlatformTabs>

### Discover apps to subscribe to

Apps wanting to provide users a list of apps that users may want to subscribe to can use this function. This list is manually curated by us, and apps can submit a request to be added to this list in our Cloud app by following [this guide](https://docs.walletconnect.com/web3inbox/cloud-setup).

<PlatformTabs
    groupId="w3iw"
    activeOptions={["react", "javascript"]}
>

<PlatformTabItem value="react">

```ts
const { data: apps, isLoading, currentPageNumber, nextPage, previousPage, getPage } = useDiscoverApps({
  isInfiniteScroll?: boolean, // Default to false
  appsPerPage?: number, // Default to 10
  isVerified?: boolean, // Filter by featured projects, defaulted to true
  isFeatured?: boolean  // Filter by verified projects, defaulted to true
})

return (
  <div>
    {apps.map(app => (
      <div onClick={app.subscribe} key={app.id}>
        <img src={app.icon} />
        <span> {app.name} </span>
        <span> {app.description} </span>
        <span> {app.url} </span>
      </div>
    )}
	<button onClick={nextPage} />
	<button onClick={previousPage} />
	<span> Page: {currentPageNumber} </span>
  </div>
)
```

#### References

- **getPage:** `(page: number) => Promise<NotifyApp[]>`, Fetch a specific page, does not affect state 
- **apps:** `NotifyApp[]`
- **isInfiniteScroll:** Whether or not to keep already fetched apps when getting next page
- **appsPerPage:** Number representing how many apps to get per fetch

```
interface NotifyApp {
  id: string // The ID of the app on the discover list
  name: string
  description: string
  url: string
  appDomain: string
  icon: string
  isVerified: boolean // Is this app verified for its domain
  isFeatured: boolean // Is this app flagged as featured 
  isComingSoon: boolean // Is this app coming soon or already available 
  subscribe: () => Promise<void>
}
```


</PlatformTabItem>

<PlatformTabItem value="javascript">

```ts

const onUpdate = ({apps, currentPage}: {apps: NotifyApp[], currentPage: number}) => {
  for(const app of apps) {
    console.log({
      id: app.id,
      name: app.name,
      url: app.url,
      icon: app.icon,
      isVerified: app.isVerified,
      isFeatured: app.isFeatured,
      isComingSoon: app.isComingSoon,
    })
  }

  // subscribe to the first app
  await app[0].subscribe()
}

const { previousPage, nextPage } = await client.pageDiscoverApps({
  isInfiniteScroll?: boolean, // Default to false
  appsPerPage?: number, // Default to 10
  isVerified?: boolean, // Filter by featured projects, defaulted to true
  isFeatured?: boolean  // Filter by verified projects, defaulted to true
})(onUpdate)

const singleFetchedApps = await client.discoverApps({
  page: 1,
  entries: 5,
  isVerified: true, // Filter by featured projects, defaulted to true
  isFeatured: true  // Filter by verified projects, defaulted to true
})


```

#### References
- **discoverApps:** `() => NotifyApp[]`
- **isInfiniteScroll:** Whether or not to keep already fetched apps when getting next page
- **appsPerPage:** Number representing how many apps to get per fetch

```
interface NotifyApp {
  id: string // The ID of the app on the discover list
  name: string
  description: string
  url: string
  appDomain: string
  icon: string
  isVerified: boolean // Is this app verified for its domain
  isFeatured: boolean // Is this app flagged as featured 
  isComingSoon: boolean // Is this app coming soon or already available 
  subscribe: () => Promise<void>
}
```



</PlatformTabItem>
</PlatformTabs>
